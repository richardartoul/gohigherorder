package main

import (
	"bufio"
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"os"
	"regexp"

	"log"
	// "os"
)

var (
	generatedTemplate = template.Must(template.New("render").Parse(`// generated by slice++ -- DO NOT EDIT
package {{.Package}}
{{range .CollectionTypes}}
// Map maps a slice of {{.Ident}} to a slice of {{.Ident}}
func (items {{.Ident}}) Map(f func({{.TypeExpr}}) {{.TypeExpr}}) {{.Ident}} {
	mapped := []{{.TypeExpr}}{}
  for _, item := range items {
    mapped = append(mapped, f(item))
  }
  return mapped
}
{{end}}
{{range .CollectionTypes}}
// Filter filters a slice of {{.Ident}} to a slice of {{.Ident}} where f({{.TypeExpr}}) is true
func (items {{.Ident}}) Filter(f func({{.TypeExpr}}) bool) {{.Ident}} {
	filtered := []{{.TypeExpr}}{}
  for _, item := range items {
		if (f(item)) {
			filtered = append(filtered, item)
		}
  }
  return filtered
}
{{end}}
`))
)

// ParsedFile contains all the information required to generate code for a file
type ParsedFile struct {
	Package         string
	CollectionTypes []*CollectionType
}

/*
CollectionType contains all the information about an annotated collection type
required to generate Map, Reduce, and Filter.

Ex.
type Users []*User
CollectionType{
  Ident: "Users",
  TypeExpr: "[]*User"
}

We parse everything into strings because the problem is simple enough that we
can use the template package to generate the code that we want instead of
constructing manually constructing an AST tree.
*/
type CollectionType struct {
	Ident    string
	TypeExpr string
}

func parseFile(inputPath string) *ParsedFile {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, inputPath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Could not parse file: %s", err)
	}

	// ast.Print(fset, f)
	packageName := identifyPackage(f)
	if packageName == "" {
		log.Fatalf("Could not determine package name of %s", inputPath)
	}

	typeSpecs := getTypeSpecsFromAST(f)
	collectionTypes := []*CollectionType{}
	for _, typeSpec := range typeSpecs {
		collectionTypes = append(
			collectionTypes,
			getCollectionTypeFromTypeSpec(typeSpec, fset),
		)
	}

	return &ParsedFile{
		Package:         packageName,
		CollectionTypes: collectionTypes,
	}
}

func getTypeSpecsFromAST(tree *ast.File) []*ast.TypeSpec {
	typeSpecs := []*ast.TypeSpec{}

	for _, decl := range tree.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}

		isAnnotated := isAnnotatedTypeDecl(genDecl)
		if !isAnnotated {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			hasName := typeSpec.Name != nil
			_, isArrayType := typeSpec.Type.(*ast.ArrayType)
			if !hasName || !isArrayType {
				continue
			}

			typeSpecs = append(typeSpecs, typeSpec)
		}
	}
	return typeSpecs
}

func isAnnotatedTypeDecl(decl *ast.GenDecl) bool {
	// Not a type declaration
	if decl.Tok != token.TYPE {
		return false
	}

	// Doesn't have an annotation
	if decl.Doc == nil {
		return false
	}

	for _, comment := range decl.Doc.List {
		// Look for slice++ or //slice++ on a newline followed by any (or no) whitespace
		isAnnotated, _ := regexp.MatchString("(?m)^(//)?slice[+][+]\\s*$", comment.Text)
		if isAnnotated {
			return true
		}
	}

	return false
}

func getCollectionTypeFromTypeSpec(
	typeSpec *ast.TypeSpec,
	fset *token.FileSet,
) *CollectionType {
	typeIdent := typeSpec.Name.Name
	var buf bytes.Buffer
	arrayType, ok := typeSpec.Type.(*ast.ArrayType)
	// This should never happen since we already filtered to ArrayTypes
	if !ok {
		log.Fatalf("Not an array type: %#v", arrayType)
	}
	if err := format.Node(&buf, fset, arrayType.Elt); err != nil {
		panic(err)
	}
	typeExpr := buf.String()
	return &CollectionType{
		Ident:    typeIdent,
		TypeExpr: typeExpr,
	}
}

func identifyPackage(f *ast.File) string {
	if f.Name == nil {
		return ""
	}
	return f.Name.Name
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("joiner: ")

	parsedFile := parseFile("test1_test.go")
	log.Println(parsedFile.Package)
	for _, collectionType := range parsedFile.CollectionTypes {
		log.Printf("%#v\n", collectionType)
	}

	f, err := os.Create("./out.go")
	if err != nil {
		log.Fatal(err)
	}

	w := bufio.NewWriter(f)
	generatedTemplate.Execute(w, parsedFile)
	w.Flush()
}
